import { Buffer as t } from 'buffer'; import * as f from 'assert';
import m from 'assert';
import { SendTransactionError as e, PublicKey as r, Transaction as n, TransactionInstruction as i, SystemProgram as o, SYSVAR_RENT_PUBKEY as s } from '@solana/web3.js'; import * as a from '@solana/web3.js';
import c from 'bn.js';
import u from 'bs58';
import * as l from 'base64-js';
import d from 'camelcase';
import { sha256 as h } from 'js-sha256';
import * as p from '@project-serum/borsh';
import { inflate as y } from 'pako';
import g from 'eventemitter3'; export { a as web3 }; export { default as BN } from 'bn.js'; const w = Object.freeze({ __proto__: null, encode: function (t) { return t.reduce((t, e) => t + e.toString(16).padStart(2, '0'), '0x'); }, decode: function (e) { e.indexOf('0x') === 0 && (e = e.substr(2)), e.length % 2 == 1 && (e = '0' + e); const r = e.match(/.{2}/g); return r === null ? t.from([]) : t.from(r.map(t => parseInt(t, 16))); } }); function v (t) { return new TextDecoder('utf-8').decode(t); } function b (t) { return (new TextEncoder()).encode(t); } const _ = Object.freeze({ __proto__: null, decode: v, encode: b }); function A (t) { return u.encode(t); } const E = Object.freeze({ __proto__: null, encode: A, decode: function (t) { return u.decode(t); } }); const S = Object.freeze({ __proto__: null, encode: function (t) { return l.fromByteArray(t); }, decode: function (e) { return t.from(l.toByteArray(e)); } }); const I = Object.freeze({ __proto__: null, hex: w, utf8: _, bs58: E, base64: S }); class k {constructor (t, e, r) { this.connection = t, this.wallet = e, this.opts = r; } static defaultOptions () { return { preflightCommitment: 'processed', commitment: 'processed' }; } static local (t, e) { throw new Error('Provider local is not available on browser.'); } static env () { throw new Error('Provider env is not available on browser.'); } async send (t, r, n) { let i; void 0 === r && (r = []), void 0 === n && (n = this.opts), t.feePayer = this.wallet.publicKey, t.recentBlockhash = (await this.connection.getLatestBlockhash(n.preflightCommitment)).blockhash, t = await this.wallet.signTransaction(t), r.filter(t => void 0 !== t).forEach((e) => { t.partialSign(e); }); const o = t.serialize(); try { return await x(this.connection, o, n); } catch (r) { if (r instanceof M) { const n = await this.connection.getTransaction(A(t.signature), { commitment: 'confirmed' }); if (n) { const t = (i = n.meta) === null || void 0 === i ? void 0 : i.logMessages; throw t ? new e(r.message, t) : r; } throw r; } throw r; } } async sendAll (t, e) { void 0 === e && (e = this.opts); const r = await this.connection.getLatestBlockhash(e.preflightCommitment); const n = t.map((t) => { const e = t.tx; let n = t.signers; return void 0 === n && (n = []), e.feePayer = this.wallet.publicKey, e.recentBlockhash = r.blockhash, n.filter(t => void 0 !== t).forEach((t) => { e.partialSign(t); }), e; }); const i = await this.wallet.signAllTransactions(n); const o = []; for (let t = 0; t < n.length; t += 1) { const r = i[t].serialize(); o.push(await x(this.connection, r, e)); } return o; } async simulate (t, e, r = this.opts) { let n, i, o; return void 0 === e && (e = []), t.feePayer = this.wallet.publicKey, t.recentBlockhash = (await this.connection.getLatestBlockhash((n = r.preflightCommitment) !== null && void 0 !== n ? n : this.opts.preflightCommitment)).blockhash, t = await this.wallet.signTransaction(t), e.filter(t => void 0 !== t).forEach((e) => { t.partialSign(e); }), await (async function (t, e, r) { e.recentBlockhash = await t._recentBlockhash(t._disableBlockhashCaching); const n = e.serializeMessage(); const i = e._serialize(n).toString('base64'); const o = [i, { encoding: 'base64', commitment: r }]; const s = await t._rpcRequest('simulateTransaction', o); if (s.error) { throw new Error('failed to simulate transaction: ' + s.error.message); } return s.result; }(this.connection, t, (o = (i = r.commitment) !== null && void 0 !== i ? i : this.opts.commitment) !== null && void 0 !== o ? o : 'processed')); }} async function x (t, e, r) { const n = r && { skipPreflight: r.skipPreflight, preflightCommitment: r.preflightCommitment || r.commitment }; const i = await t.sendRawTransaction(e, n); const o = (await t.confirmTransaction(i, r && r.commitment)).value; if (o.err) { throw new M(`Raw transaction ${i} failed (${JSON.stringify(o)})`); } return i; } class M extends Error {constructor (t) { super(t); }} function L (t) { P = t; } function T () { return P === null ? k.local() : P; }let P = null; const B = new Set(['anchor-deprecated-state', 'debug-logs']); const O = new Map(); function z (t) { return void 0 !== O.get(t); } const C = Object.freeze({ __proto__: null, set: function (t) { if (!B.has(t)) { throw new Error('Invalid feature'); } O.set(t, !0); }, isSet: z }); class D extends Error {constructor (t) { super(t), this.name = 'IdlError'; }} class U {constructor (t) { this.stack = t; } static parse (t) { let e; const n = /^Program (\w*) invoke/; const i = /^Program \w* success/; const o = []; for (let s = 0; s < t.length; s++) { if (i.exec(t[s])) { o.pop(); continue; } const a = (e = n.exec(t[s])) === null || void 0 === e ? void 0 : e[1]; a && o.push(new r(a)); } return new U(o); }} class j extends Error {constructor (t, e, r, n, i, o) { super(r.join('\n').replace('Program log: ', '')), this.errorLogs = r, this.logs = n, this.error = { errorCode: t, errorMessage: e, comparedValues: o, origin: i }, this._programErrorStack = U.parse(n); } static parse (t) { if (!t) { return null; } const e = t.findIndex(t => t.startsWith('Program log: AnchorError')); if (e === -1) { return null; } const n = t[e]; const i = [n]; let o; if (e + 1 < t.length) { if (t[e + 1] === 'Program log: Left:') { const n = /^Program log: (.*)$/; const s = n.exec(t[e + 2])[1]; const a = n.exec(t[e + 4])[1]; o = [new r(s), new r(a)], i.push(...t.slice(e + 1, e + 5)); } else if (t[e + 1].startsWith('Program log: Left:')) { const r = /^Program log: (Left|Right): (.*)$/; const n = r.exec(t[e + 1])[2]; const s = r.exec(t[e + 2])[2]; i.push(...t.slice(e + 1, e + 3)), o = [n, s]; } } const s = /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(n); const a = /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(n); const c = /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(n); if (s) { const [e, r, n] = s.slice(1, 4); const a = { code: e, number: parseInt(r) }; return new j(a, n, i, t, void 0, o); } if (a) { const [e, r, n, s, c] = a.slice(1, 6); const u = { code: n, number: parseInt(s) }; const l = { file: e, line: parseInt(r) }; return new j(u, c, i, t, l, o); } if (c) { const [e, r, n, s] = c.slice(1, 5); const a = e; const u = { code: r, number: parseInt(n) }; return new j(u, s, i, t, a, o); } return null; } get program () { return this._programErrorStack.stack[this._programErrorStack.stack.length - 1]; } get programErrorStack () { return this._programErrorStack.stack; }toString () { return this.message; }} class $ extends Error {constructor (t, e, r) { super(), this.code = t, this.msg = e, this.logs = r, r && (this._programErrorStack = U.parse(r)); } static parse (t, e) { const r = t.toString(); let n, i; if (r.includes('custom program error:')) { const t = r.split('custom program error: '); if (t.length !== 2) { return null; } n = t[1]; } else { const t = r.match(/"Custom":([0-9]+)}/g); if (!t || t.length > 1) { return null; } n = t[0].match(/([0-9]+)/g)[0]; } try { i = parseInt(n); } catch (t) { return null; }let o = e.get(i); return void 0 !== o ? new $(i, o, t.logs) : (o = V.get(i), void 0 !== o ? new $(i, o, t.logs) : null); } get program () { let t; return (t = this._programErrorStack) === null || void 0 === t ? void 0 : t.stack[this._programErrorStack.stack.length - 1]; } get programErrorStack () { let t; return (t = this._programErrorStack) === null || void 0 === t ? void 0 : t.stack; }toString () { return this.msg; }} function R (t, e) { z('debug-logs') && console.log('Translating error:', t); const r = j.parse(t.logs); if (r) { return r; } const n = $.parse(t, e); if (n) { return n; } if (t.logs) { const e = { get: function (e, r) { return r === 'programErrorStack' ? e.programErrorStack.stack : r === 'program' ? e.programErrorStack.stack[t.programErrorStack.stack.length - 1] : Reflect.get(...arguments); } }; return t.programErrorStack = U.parse(t.logs), new Proxy(t, e); } return t; } const V = new Map([[100, '8 byte instruction identifier not provided'], [101, 'Fallback functions are not supported'], [102, 'The program could not deserialize the given instruction'], [103, 'The program could not serialize the given instruction'], [1e3, 'The program was compiled without idl instructions'], [1001, 'The transaction was given an invalid program for the IDL instruction'], [2e3, 'A mut constraint was violated'], [2001, 'A has_one constraint was violated'], [2002, 'A signer constraint was violated'], [2003, 'A raw constraint was violated'], [2004, 'An owner constraint was violated'], [2005, 'A rent exemption constraint was violated'], [2006, 'A seeds constraint was violated'], [2007, 'An executable constraint was violated'], [2008, 'A state constraint was violated'], [2009, 'An associated constraint was violated'], [2010, 'An associated init constraint was violated'], [2011, 'A close constraint was violated'], [2012, 'An address constraint was violated'], [2013, 'Expected zero account discriminant'], [2014, 'A token mint constraint was violated'], [2015, 'A token owner constraint was violated'], [2016, 'A mint mint authority constraint was violated'], [2017, 'A mint freeze authority constraint was violated'], [2018, 'A mint decimals constraint was violated'], [2019, 'A space constraint was violated'], [2500, 'A require expression was violated'], [2501, 'A require_eq expression was violated'], [2502, 'A require_keys_eq expression was violated'], [2503, 'A require_neq expression was violated'], [2504, 'A require_keys_neq expression was violated'], [2505, 'A require_gt expression was violated'], [2506, 'A require_gte expression was violated'], [3e3, 'The account discriminator was already set on this account'], [3001, 'No 8 byte discriminator was found on the account'], [3002, '8 byte discriminator did not match what was expected'], [3003, 'Failed to deserialize the account'], [3004, 'Failed to serialize the account'], [3005, 'Not enough account keys given to the instruction'], [3006, 'The given account is not mutable'], [3007, 'The given account is owned by a different program than expected'], [3008, 'Program ID was not as expected'], [3009, 'Program account is not executable'], [3010, 'The given account did not sign'], [3011, 'The given account is not owned by the system program'], [3012, 'The program expected this account to be already initialized'], [3013, 'The given account is not a program data account'], [3014, 'The given account is not the associated token account'], [3015, 'The given public key does not match the required sysvar'], [4e3, 'The given state account does not have the correct address'], [4100, 'The declared program id does not match the actual program id'], [5e3, 'The API being used is deprecated and should no longer be used']]);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var N = function () { return N = Object.assign || function (t) { for (var e, r = 1, n = arguments.length; r < n; r++) { for (const i in e = arguments[r]) { Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); } } return t; }, N.apply(this, arguments); }; var K = function () { return K = Object.assign || function (t) { for (var e, r = 1, n = arguments.length; r < n; r++) { for (const i in e = arguments[r]) { Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); } } return t; }, K.apply(this, arguments); };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function F (t) { return t.toLowerCase(); } const q = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g]; const W = /[^A-Z0-9]+/gi; function G (t, e, r) { return e instanceof RegExp ? t.replace(e, r) : e.reduce(function (t, e) { return t.replace(e, r); }, t); } function H (t, e) { return void 0 === e && (e = {}), (function (t, e) { void 0 === e && (e = {}); for (var r = e.splitRegexp, n = void 0 === r ? q : r, i = e.stripRegexp, o = void 0 === i ? W : i, s = e.transform, a = void 0 === s ? F : s, c = e.delimiter, u = void 0 === c ? ' ' : c, l = G(G(t, n, '$1\0$2'), o, '\0'), d = 0, h = l.length; l.charAt(d) === '\0';) { d++; } for (;l.charAt(h - 1) === '\0';) { h--; } return l.slice(d, h).split('\0').map(a).join(u); }(t, K({ delimiter: '.' }, e))); } class J {static fieldLayout (t, e) { const r = void 0 !== t.name ? d(t.name) : void 0; switch (t.type) { case 'bool':return p.bool(r); case 'u8':return p.u8(r); case 'i8':return p.i8(r); case 'u16':return p.u16(r); case 'i16':return p.i16(r); case 'u32':return p.u32(r); case 'i32':return p.i32(r); case 'f32':return p.f32(r); case 'u64':return p.u64(r); case 'i64':return p.i64(r); case 'f64':return p.f64(r); case 'u128':return p.u128(r); case 'i128':return p.i128(r); case 'bytes':return p.vecU8(r); case 'string':return p.str(r); case 'publicKey':return p.publicKey(r); default:if ('vec' in t.type) { return p.vec(J.fieldLayout({ name: void 0, type: t.type.vec }, e), r); } if ('option' in t.type) { return p.option(J.fieldLayout({ name: void 0, type: t.type.option }, e), r); } if ('defined' in t.type) { const n = t.type.defined; if (void 0 === e) { throw new D('User defined types not provided'); } const i = e.filter(t => t.name === n); if (i.length !== 1) { throw new D(`Type not found: ${JSON.stringify(t)}`); } return J.typeDefLayout(i[0], e, r); } if ('array' in t.type) { const n = t.type.array[0]; const i = t.type.array[1]; const o = J.fieldLayout({ name: void 0, type: n }, e); return p.array(o, i, r); } throw new Error(`Not yet implemented: ${t}`); } } static typeDefLayout (t, e = [], r) { if (t.type.kind === 'struct') { const n = t.type.fields.map(t => J.fieldLayout(t, e)); return p.struct(n, r); } if (t.type.kind === 'enum') { const n = t.type.variants.map((t) => { const r = d(t.name); if (void 0 === t.fields) { return p.struct([], r); } const n = t.fields.map((t) => { if (!t.hasOwnProperty('name')) { throw new Error('Tuple enum variants not yet implemented.'); } return J.fieldLayout(t, e); }); return p.struct(n, r); }); return void 0 !== r ? p.rustEnum(n).replicate(r) : p.rustEnum(n, r); } throw new Error(`Unknown type kint: ${t}`); }} class Z {constructor (t) { this.idl = t, this.ixLayout = Z.parseIxLayout(t); const e = new Map(); t.instructions.forEach((t) => { const r = X('global', t.name); e.set(u.encode(r), { layout: this.ixLayout.get(t.name), name: t.name }); }), t.state && t.state.methods.map((t) => { const r = X('state', t.name); e.set(u.encode(r), { layout: this.ixLayout.get(t.name), name: t.name }); }), this.sighashLayouts = e; }encode (t, e) { return this._encode('global', t, e); }encodeState (t, e) { return this._encode('state', t, e); }_encode (e, r, n) { const i = t.alloc(1e3); const o = d(r); const s = this.ixLayout.get(o); if (!s) { throw new Error(`Unknown method: ${o}`); } const a = s.encode(n, i); const c = i.slice(0, a); return t.concat([X(e, r), c]); } static parseIxLayout (t) { const e = (t.state ? t.state.methods : []).map((e) => { const r = e.args.map((e) => { let r, n; return J.fieldLayout(e, Array.from([...(r = t.accounts) !== null && void 0 !== r ? r : [], ...(n = t.types) !== null && void 0 !== n ? n : []])); }); const n = d(e.name); return [n, p.struct(r, n)]; }).concat(t.instructions.map((e) => { const r = e.args.map((e) => { let r, n; return J.fieldLayout(e, Array.from([...(r = t.accounts) !== null && void 0 !== r ? r : [], ...(n = t.types) !== null && void 0 !== n ? n : []])); }); const n = d(e.name); return [n, p.struct(r, n)]; })); return new Map(e); }decode (e, r = 'hex') { typeof e === 'string' && (e = r === 'hex' ? t.from(e, 'hex') : u.decode(e)); const n = u.encode(e.slice(0, 8)); const i = e.slice(8); const o = this.sighashLayouts.get(n); return o ? { data: o.layout.decode(i), name: o.name } : null; }format (t, e) { return Q.format(t, e, this.idl); }} class Q {static format (t, e, r) { const n = r.instructions.filter(e => t.name === e.name)[0]; if (void 0 === n) { return console.error('Invalid instruction given'), null; } const i = n.args.map(e => ({ name: e.name, type: Q.formatIdlType(e.type), data: Q.formatIdlData(e, t.data[e.name], r.types) })); const o = Q.flattenIdlAccounts(n.accounts); return { args: i, accounts: e.map((t, e) => e < o.length ? { name: o[e].name, ...t } : { name: void 0, ...t }) }; } static formatIdlType (t) { if (typeof t === 'string') { return t; } if ('vec' in t) { return `Vec<${this.formatIdlType(t.vec)}>`; } if ('option' in t) { return `Option<${this.formatIdlType(t.option)}>`; } if ('defined' in t) { return t.defined; } if ('array' in t) { return `Array<${t.array[0]}; ${t.array[1]}>`; } throw new Error(`Unknown IDL type: ${t}`); } static formatIdlData (t, e, r) { if (typeof t.type === 'string') { return e.toString(); } if (t.type.hasOwnProperty('vec')) { return '[' + e.map(e => this.formatIdlData({ name: '', type: t.type.vec }, e)).join(', ') + ']'; } if (t.type.hasOwnProperty('option')) { return e === null ? 'null' : this.formatIdlData({ name: '', type: t.type.option }, e, r); } if (t.type.hasOwnProperty('defined')) { if (void 0 === r) { throw new Error('User defined types not provided'); } const n = r.filter(e => e.name === t.type.defined); if (n.length !== 1) { throw new Error(`Type not found: ${t.type.defined}`); } return Q.formatIdlDataDefined(n[0], e, r); } return 'unknown'; } static formatIdlDataDefined (t, e, r) { if (t.type.kind === 'struct') { const n = t.type; return '{ ' + Object.keys(e).map((t) => { const i = n.fields.filter(e => e.name === t)[0]; if (void 0 === i) { throw new Error('Unable to find type'); } return t + ': ' + Q.formatIdlData(i, e[t], r); }).join(', ') + ' }'; } if (t.type.variants.length === 0) { return '{}'; } if (t.type.variants[0].name) { const n = t.type.variants; const i = Object.keys(e)[0]; const o = e[i]; const s = Object.keys(o).map((t) => { let e; const s = o[t]; const a = (e = n[i]) === null || void 0 === e ? void 0 : e.filter(e => e.name === t)[0]; if (void 0 === a) { throw new Error('Unable to find variant'); } return t + ': ' + Q.formatIdlData(a, s, r); }).join(', '); const a = d(i, { pascalCase: !0 }); return s.length === 0 ? a : `${a} { ${s} }`; } return 'Tuple formatting not yet implemented'; } static flattenIdlAccounts (t, e) { return t.map((t) => { const r = (function (t) { const e = t.replace(/([A-Z])/g, ' $1'); return e.charAt(0).toUpperCase() + e.slice(1); }(t.name)); if (t.hasOwnProperty('accounts')) { const n = e ? `${e} > ${r}` : r; return Q.flattenIdlAccounts(t.accounts, n); } return { ...t, name: e ? `${e} > ${r}` : r }; }).flat(); }} function X (e, r) { let n; const i = `${e}:${void 0 === n && (n = {}), H(r, N({ delimiter: '_' }, n))}`; return t.from(h.digest(i)).slice(0, 8); } function Y (t, e) { if (e.type.kind === 'enum') { const r = e.type.variants.map(e => void 0 === e.fields ? 0 : e.fields.map((e) => { if (typeof e !== 'object' || !('name' in e)) { throw new Error('Tuple enum variants not yet implemented.'); } return tt(t, e.type); }).reduce((t, e) => t + e)); return Math.max(...r) + 1; } return void 0 === e.type.fields ? 0 : e.type.fields.map(e => tt(t, e.type)).reduce((t, e) => t + e, 0); } function tt (t, e) { let r, n; switch (e) { case 'bool':case 'u8':case 'i8':case 'bytes':case 'string':return 1; case 'i16':case 'u16':return 2; case 'u32':case 'i32':case 'f32':return 4; case 'u64':case 'i64':case 'f64':return 8; case 'u128':case 'i128':return 16; case 'publicKey':return 32; default:if ('vec' in e) { return 1; } if ('option' in e) { return 1 + tt(t, e.option); } if ('coption' in e) { return 4 + tt(t, e.coption); } if ('defined' in e) { const i = (n = (r = t.types) === null || void 0 === r ? void 0 : r.filter(t => t.name === e.defined)) !== null && void 0 !== n ? n : []; if (i.length !== 1) { throw new D(`Type not found: ${JSON.stringify(e)}`); } return Y(t, i[0]); } if ('array' in e) { const r = e.array[0]; const n = e.array[1]; return tt(t, r) * n; } throw new Error(`Invalid type ${JSON.stringify(e)}`); } } const et = 8; class rt {constructor (t) { if (void 0 === t.accounts) { return void (this.accountLayouts = new Map()); } const e = t.accounts.map(e => [e.name, J.typeDefLayout(e, t.types)]); this.accountLayouts = new Map(e), this.idl = t; } async encode (e, r) { const n = t.alloc(1e3); const i = this.accountLayouts.get(e); if (!i) { throw new Error(`Unknown account: ${e}`); } const o = i.encode(r, n); const s = n.slice(0, o); const a = rt.accountDiscriminator(e); return t.concat([a, s]); }decode (t, e) { if (rt.accountDiscriminator(t).compare(e.slice(0, 8))) { throw new Error('Invalid account discriminator'); } return this.decodeUnchecked(t, e); }decodeUnchecked (t, e) { const r = e.slice(8); const n = this.accountLayouts.get(t); if (!n) { throw new Error(`Unknown account: ${t}`); } return n.decode(r); }memcmp (e, r) { const n = rt.accountDiscriminator(e); return { offset: 0, bytes: u.encode(r ? t.concat([n, r]) : n) }; }size (t) { let e; return 8 + ((e = Y(this.idl, t)) !== null && void 0 !== e ? e : 0); } static accountDiscriminator (e) { return t.from(h.digest(`account:${d(e, { pascalCase: !0 })}`)).slice(0, 8); }} class nt {constructor (t) { if (void 0 === t.events) { return void (this.layouts = new Map()); } const e = t.events.map((e) => { const r = { name: e.name, type: { kind: 'struct', fields: e.fields.map(t => ({ name: t.name, type: t.type })) } }; return [e.name, J.typeDefLayout(r, t.types)]; }); this.layouts = new Map(e), this.discriminators = new Map(void 0 === t.events ? [] : t.events.map(t => [l.fromByteArray(it(t.name)), t.name])); }decode (e) { let r; try { r = t.from(l.toByteArray(e)); } catch (t) { return null; } const n = l.fromByteArray(r.slice(0, 8)); const i = this.discriminators.get(n); if (void 0 === i) { return null; } const o = this.layouts.get(i); if (!o) { throw new Error(`Unknown event: ${i}`); } return { data: o.decode(r.slice(8)), name: i }; }} function it (e) { return t.from(h.digest(`event:${e}`)).slice(0, 8); } class ot {constructor (t) { if (void 0 === t.state) { throw new Error('Idl state not defined.'); } this.layout = J.typeDefLayout(t.state.struct, t.types); } async encode (e, r) { const n = t.alloc(1e3); const i = this.layout.encode(r, n); const o = await st(e); const s = n.slice(0, i); return t.concat([o, s]); }decode (t) { const e = t.slice(8); return this.layout.decode(e); }} async function st (e) { const r = z('anchor-deprecated-state') ? 'account' : 'state'; return t.from(h.digest(`${r}:${e}`)).slice(0, 8); } class at {constructor (t) { this.instruction = new Z(t), this.accounts = new rt(t), this.events = new nt(t), t.state && (this.state = new ot(t)); }} const ct = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}; function ut (t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, 'default') ? t.default : t; } class lt {constructor (t, e) { if (!Number.isInteger(t)) { throw new TypeError('span must be an integer'); } this.span = t, this.property = e; }makeDestinationObject () { return {}; }decode (t, e) { throw new Error('Layout is abstract'); }encode (t, e, r) { throw new Error('Layout is abstract'); }getSpan (t, e) { if (this.span < 0) { throw new RangeError('indeterminate span'); } return this.span; }replicate (t) { const e = Object.create(this.constructor.prototype); return Object.assign(e, this), e.property = t, e; }fromArray (t) {}} const dt = lt; class ht extends lt {isCount () { throw new Error('ExternalLayout is abstract'); }} class pt extends ht {constructor (t, e, r) { if (!(t instanceof lt)) { throw new TypeError('layout must be a Layout'); } if (void 0 === e) { e = 0; } else if (!Number.isInteger(e)) { throw new TypeError('offset must be integer or undefined'); } super(t.span, r || t.property), this.layout = t, this.offset = e; }isCount () { return this.layout instanceof ft || this.layout instanceof mt; }decode (t, e) { return void 0 === e && (e = 0), this.layout.decode(t, e + this.offset); }encode (t, e, r) { return void 0 === r && (r = 0), this.layout.encode(t, e, r + this.offset); }} class ft extends lt {constructor (t, e) { if (super(t, e), this.span > 6) { throw new RangeError('span must not exceed 6 bytes'); } }decode (t, e) { return void 0 === e && (e = 0), t.readUIntLE(e, this.span); }encode (t, e, r) { return void 0 === r && (r = 0), e.writeUIntLE(t, r, this.span), this.span; }} class mt extends lt {constructor (t, e) { if (super(t, e), this.span > 6) { throw new RangeError('span must not exceed 6 bytes'); } }decode (t, e) { return void 0 === e && (e = 0), t.readUIntBE(e, this.span); }encode (t, e, r) { return void 0 === r && (r = 0), e.writeUIntBE(t, r, this.span), this.span; }} const yt = Math.pow(2, 32); class gt extends lt {constructor (t) { super(8, t); }decode (t, e) { void 0 === e && (e = 0); const r = t.readUInt32LE(e); return (function (t, e) { return t * yt + e; }(t.readUInt32LE(e + 4), r)); }encode (t, e, r) { void 0 === r && (r = 0); const n = (function (t) { const e = Math.floor(t / yt); return { hi32: e, lo32: t - e * yt }; }(t)); return e.writeUInt32LE(n.lo32, r), e.writeUInt32LE(n.hi32, r + 4), 8; }} class wt extends lt {constructor (t, e, r) { if (!Array.isArray(t) || !t.reduce((t, e) => t && e instanceof lt, !0)) { throw new TypeError('fields must be array of Layout instances'); } typeof e === 'boolean' && void 0 === r && (r = e, e = void 0); for (const e of t) { if (e.span < 0 && void 0 === e.property) { throw new Error('fields cannot contain unnamed variable-length layout'); } } let n = -1; try { n = t.reduce((t, e) => t + e.getSpan(), 0); } catch (t) {} super(n, e), this.fields = t, this.decodePrefixes = !!r; }getSpan (t, e) { if (this.span >= 0) { return this.span; } void 0 === e && (e = 0); let r = 0; try { r = this.fields.reduce((r, n) => { const i = n.getSpan(t, e); return e += i, r + i; }, 0); } catch (t) { throw new RangeError('indeterminate span'); } return r; }decode (t, e) { void 0 === e && (e = 0); const r = this.makeDestinationObject(); for (const n of this.fields) { if (void 0 !== n.property && (r[n.property] = n.decode(t, e)), e += n.getSpan(t, e), this.decodePrefixes && t.length === e) { break; } } return r; }encode (t, e, r) { void 0 === r && (r = 0); const n = r; let i = 0; let o = 0; for (const n of this.fields) { let s = n.span; if (o = s > 0 ? s : 0, void 0 !== n.property) { const i = t[n.property]; void 0 !== i && (o = n.encode(i, e, r), s < 0 && (s = n.getSpan(e, r))); }i = r, r += s; } return i + o - n; }fromArray (t) { const e = this.makeDestinationObject(); for (const r of this.fields) { void 0 !== r.property && t.length > 0 && (e[r.property] = t.shift()); } return e; }layoutFor (t) { if (typeof t !== 'string') { throw new TypeError('property must be string'); } for (const e of this.fields) { if (e.property === t) { return e; } } }offsetOf (t) { if (typeof t !== 'string') { throw new TypeError('property must be string'); } let e = 0; for (const r of this.fields) { if (r.property === t) { return e; } r.span < 0 ? e = -1 : e >= 0 && (e += r.span); } }} class vt {constructor (t) { this.property = t; }decode () { throw new Error('UnionDiscriminator is abstract'); }encode () { throw new Error('UnionDiscriminator is abstract'); }} class bt extends vt {constructor (t, e) { if (!(t instanceof ht && t.isCount())) { throw new TypeError('layout must be an unsigned integer ExternalLayout'); } super(e || t.property || 'variant'), this.layout = t; }decode (t, e) { return this.layout.decode(t, e); }encode (t, e, r) { return this.layout.encode(t, e, r); }} class _t extends lt {constructor (t, e, r) { const n = t instanceof ft || t instanceof mt; if (n) { t = new bt(new pt(t)); } else if (t instanceof ht && t.isCount()) { t = new bt(t); } else if (!(t instanceof vt)) { throw new TypeError('discr must be a UnionDiscriminator or an unsigned integer layout'); } if (void 0 === e && (e = null), !(e === null || e instanceof lt)) { throw new TypeError('defaultLayout must be null or a Layout'); } if (e !== null) { if (e.span < 0) { throw new Error('defaultLayout must have constant span'); } void 0 === e.property && (e = e.replicate('content')); }let i = -1; e && (i = e.span, i >= 0 && n && (i += t.layout.span)), super(i, r), this.discriminator = t, this.usesPrefixDiscriminator = n, this.defaultLayout = e, this.registry = {}; let o = this.defaultGetSourceVariant.bind(this); this.getSourceVariant = function (t) { return o(t); }, this.configGetSourceVariant = function (t) { o = t.bind(this); }; }getSpan (t, e) { if (this.span >= 0) { return this.span; } void 0 === e && (e = 0); const r = this.getVariant(t, e); if (!r) { throw new Error('unable to determine span for unrecognized variant'); } return r.getSpan(t, e); }defaultGetSourceVariant (t) { if (t.hasOwnProperty(this.discriminator.property)) { if (this.defaultLayout && t.hasOwnProperty(this.defaultLayout.property)) { return; } const e = this.registry[t[this.discriminator.property]]; if (e && (!e.layout || t.hasOwnProperty(e.property))) { return e; } } else { for (const e in this.registry) { const r = this.registry[e]; if (t.hasOwnProperty(r.property)) { return r; } } } throw new Error('unable to infer src variant'); }decode (t, e) { let r; void 0 === e && (e = 0); const n = this.discriminator; const i = n.decode(t, e); let o = this.registry[i]; if (void 0 === o) { let s = 0; o = this.defaultLayout, this.usesPrefixDiscriminator && (s = n.layout.span), r = this.makeDestinationObject(), r[n.property] = i, r[o.property] = this.defaultLayout.decode(t, e + s); } else { r = o.decode(t, e); } return r; }encode (t, e, r) { void 0 === r && (r = 0); const n = this.getSourceVariant(t); if (void 0 === n) { const n = this.discriminator; const i = this.defaultLayout; let o = 0; return this.usesPrefixDiscriminator && (o = n.layout.span), n.encode(t[n.property], e, r), o + i.encode(t[i.property], e, r + o); } return n.encode(t, e, r); }addVariant (t, e, r) { const n = new At(this, t, e, r); return this.registry[t] = n, n; }getVariant (t, e) { let r = t; return Buffer.isBuffer(t) && (void 0 === e && (e = 0), r = this.discriminator.decode(t, e)), this.registry[r]; }} class At extends lt {constructor (t, e, r, n) { if (!(t instanceof _t)) { throw new TypeError('union must be a Union'); } if (!Number.isInteger(e) || e < 0) { throw new TypeError('variant must be a (non-negative) integer'); } if (typeof r === 'string' && void 0 === n && (n = r, r = null), r) { if (!(r instanceof lt)) { throw new TypeError('layout must be a Layout'); } if (t.defaultLayout !== null && r.span >= 0 && r.span > t.defaultLayout.span) { throw new Error('variant span exceeds span of containing union'); } if (typeof n !== 'string') { throw new TypeError('variant must have a String property'); } }let i = t.span; t.span < 0 && (i = r ? r.span : 0, i >= 0 && t.usesPrefixDiscriminator && (i += t.discriminator.layout.span)), super(i, n), this.union = t, this.variant = e, this.layout = r || null; }getSpan (t, e) { if (this.span >= 0) { return this.span; } void 0 === e && (e = 0); let r = 0; return this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), r + this.layout.getSpan(t, e + r); }decode (t, e) { const r = this.makeDestinationObject(); if (void 0 === e && (e = 0), this !== this.union.getVariant(t, e)) { throw new Error('variant mismatch'); } let n = 0; return this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span), this.layout ? r[this.property] = this.layout.decode(t, e + n) : this.property ? r[this.property] = !0 : this.union.usesPrefixDiscriminator && (r[this.union.discriminator.property] = this.variant), r; }encode (t, e, r) { void 0 === r && (r = 0); let n = 0; if (this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span), this.layout && !t.hasOwnProperty(this.property)) { throw new TypeError('variant lacks property ' + this.property); } this.union.discriminator.encode(this.variant, e, r); let i = n; if (this.layout && (this.layout.encode(t[this.property], e, r + n), i += this.layout.getSpan(e, r + n), this.union.span >= 0 && i > this.union.span)) { throw new Error('encoded variant overruns containing union'); } return i; }fromArray (t) { if (this.layout) { return this.layout.fromArray(t); } }} class Et extends lt {constructor (t, e) { if (!(t instanceof ht && t.isCount() || Number.isInteger(t) && t >= 0)) { throw new TypeError('length must be positive integer or an unsigned integer ExternalLayout'); } let r = -1; t instanceof ht || (r = t), super(r, e), this.length = t; }getSpan (t, e) { let r = this.span; return r < 0 && (r = this.length.decode(t, e)), r; }decode (t, e) { void 0 === e && (e = 0); let r = this.span; return r < 0 && (r = this.length.decode(t, e)), t.slice(e, e + r); }encode (t, e, r) { let n = this.length; if (this.length instanceof ht && (n = t.length), !Buffer.isBuffer(t) || n !== t.length) { throw new TypeError((i = 'Blob.encode', ((o = this).property ? i + '[' + o.property + ']' : i) + ' requires (length ' + n + ') Buffer as src')); } let i, o; if (r + n > e.length) { throw new RangeError('encoding overruns Buffer'); } return e.write(t.toString('hex'), r, n, 'hex'), this.length instanceof ht && this.length.encode(n, e, r), n; }} const St = t => new ft(1, t); const It = t => new gt(t); const kt = (t, e, r) => new wt(t, e, r); const xt = (t, e) => new Et(t, e); class Mt {constructor (t) {}encode (t, e) { switch (d(t)) { case 'initializeMint':return (function ({ decimals: t, mintAuthority: e, freezeAuthority: n }) { return zt({ initializeMint: { decimals: t, mintAuthority: e.toBuffer(), freezeAuthorityOption: !!n, freezeAuthority: (n || r.default).toBuffer() } }); }(e)); case 'initializeAccount':return zt({ initializeAccount: {} }); case 'initializeMultisig':return (function ({ m: t }) { return zt({ initializeMultisig: { m: t } }); }(e)); case 'transfer':return (function ({ amount: t }) { return zt({ transfer: { amount: t } }); }(e)); case 'approve':return (function ({ amount: t }) { return zt({ approve: { amount: t } }); }(e)); case 'revoke':return zt({ revoke: {} }); case 'setAuthority':return (function ({ authorityType: t, newAuthority: e }) { return zt({ setAuthority: { authorityType: t, newAuthority: e } }); }(e)); case 'mintTo':return (function ({ amount: t }) { return zt({ mintTo: { amount: t } }); }(e)); case 'burn':return (function ({ amount: t }) { return zt({ burn: { amount: t } }); }(e)); case 'closeAccount':return zt({ closeAccount: {} }); case 'freezeAccount':return zt({ freezeAccount: {} }); case 'thawAccount':return zt({ thawAccount: {} }); case 'transferChecked':return (function ({ amount: t, decimals: e }) { return zt({ transferChecked: { amount: t, decimals: e } }); }(e)); case 'approvedChecked':return (function ({ amount: t, decimals: e }) { return zt({ approveChecked: { amount: t, decimals: e } }); }(e)); case 'mintToChecked':return (function ({ amount: t, decimals: e }) { return zt({ mintToChecked: { amount: t, decimals: e } }); }(e)); case 'burnChecked':return (function ({ amount: t, decimals: e }) { return zt({ burnChecked: { amount: t, decimals: e } }); }(e)); case 'intializeAccount2':return (function ({ authority: t }) { return zt({ initilaizeAccount2: { authority: t } }); }(e)); case 'syncNative':return zt({ syncNative: {} }); case 'initializeAccount3':return (function ({ authority: t }) { return zt({ initializeAccount3: { authority: t } }); }(e)); case 'initializeMultisig2':return (function ({ m: t }) { return zt({ initializeMultisig2: { m: t } }); }(e)); case 'initializeMint2':return (function ({ decimals: t, mintAuthority: e, freezeAuthority: r }) { return zt({ encodeInitializeMint2: { decimals: t, mintAuthority: e, freezeAuthority: r } }); }(e)); default:throw new Error(`Invalid instruction: ${t}`); } }encodeState (t, e) { throw new Error('SPL token does not have state'); }} const Lt = (Tt = St('instruction'), new _t(Tt, Pt, Bt)); let Tt, Pt, Bt; function Ot (t) { return xt(32, t); } function zt (t) { const e = Buffer.alloc(Ct); const r = Lt.encode(t, e); return e.slice(0, r); }Lt.addVariant(0, kt([St('decimals'), xt(32, 'mintAuthority'), St('freezeAuthorityOption'), Ot('freezeAuthority')]), 'initializeMint'), Lt.addVariant(1, kt([]), 'initializeAccount'), Lt.addVariant(2, kt([St('m')]), 'initializeMultisig'), Lt.addVariant(3, kt([It('amount')]), 'transfer'), Lt.addVariant(4, kt([It('amount')]), 'approve'), Lt.addVariant(5, kt([]), 'revoke'), Lt.addVariant(6, kt([St('authorityType'), St('newAuthorityOption'), Ot('newAuthority')]), 'setAuthority'), Lt.addVariant(7, kt([It('amount')]), 'mintTo'), Lt.addVariant(8, kt([It('amount')]), 'burn'), Lt.addVariant(9, kt([]), 'closeAccount'), Lt.addVariant(10, kt([]), 'freezeAccount'), Lt.addVariant(11, kt([]), 'thawAccount'), Lt.addVariant(12, kt([It('amount'), St('decimals')]), 'transferChecked'), Lt.addVariant(13, kt([It('amount'), St('decimals')]), 'approvedChecked'), Lt.addVariant(14, kt([It('amount'), St('decimals')]), 'mintToChecked'), Lt.addVariant(15, kt([It('amount'), St('decimals')]), 'burnedChecked'), Lt.addVariant(16, kt([Ot('authority')]), 'InitializeAccount2'), Lt.addVariant(17, kt([]), 'syncNative'), Lt.addVariant(18, kt([Ot('authority')]), 'initializeAccount3'), Lt.addVariant(19, kt([St('m')]), 'initializeMultisig2'), Lt.addVariant(20, kt([St('decimals'), Ot('mintAuthority'), St('freezeAuthorityOption'), Ot('freezeAuthority')]), 'initializeMint2'); const Ct = Math.max(...Object.values(Lt.registry).map(t => t.span)); class Dt {constructor (t) {}encode (t, e) { throw new Error('SPL token does not have state'); }decode (t) { throw new Error('SPL token does not have state'); }} function Ut (t) { return new Rt(xt(8), t => Ft.fromBuffer(t), t => t.toBuffer(), t); } function jt (t) { return new Rt(xt(32), t => new r(t), t => t.toBuffer(), t); } function $t (t, e) { return new Vt(t, e); } class Rt extends dt {constructor (t, e, r, n) { super(t.span, n), this.layout = t, this.decoder = e, this.encoder = r; }decode (t, e) { return this.decoder(this.layout.decode(t, e)); }encode (t, e, r) { return this.layout.encode(this.encoder(t), e, r); }getSpan (t, e) { return this.layout.getSpan(t, e); }} class Vt extends dt {constructor (t, e) { super(-1, e), this.layout = t, this.discriminator = (t => new ft(4, t))(); }encode (t, e, r = 0) { return t == null ? this.layout.span + this.discriminator.encode(0, e, r) : (this.discriminator.encode(1, e, r), this.layout.encode(t, e, r + 4) + 4); }decode (t, e = 0) { const r = this.discriminator.decode(t, e); if (r === 0) { return null; } if (r === 1) { return this.layout.decode(t, e + 4); } throw new Error('Invalid coption ' + this.layout.property); }getSpan (t, e = 0) { return this.layout.getSpan(t, e + 4) + 4; }} function Nt (t) { if (t === 0) { return !1; } if (t === 1) { return !0; } throw new Error('Invalid bool: ' + t); } function Kt (t) { return t ? 1 : 0; } class Ft extends c {toBuffer () { const t = super.toArray().reverse(); const e = Buffer.from(t); if (e.length === 8) { return e; } if (e.length >= 8) { throw new Error('u64 too large'); } const r = Buffer.alloc(8); return e.copy(r), r; } static fromBuffer (t) { if (t.length !== 8) { throw new Error(`Invalid buffer length: ${t.length}`); } return new Ft([...t].reverse().map(t => `00${t.toString(16)}`.slice(-2)).join(''), 16); }} class qt {constructor (t) { this.idl = t; } async encode (t, e) { switch (t) { case 'token': { const t = Buffer.alloc(165); const r = Gt.encode(e, t); return t.slice(0, r); } case 'mint': { const t = Buffer.alloc(82); const r = Wt.encode(e, t); return t.slice(0, r); } default:throw new Error(`Invalid account name: ${t}`); } }decode (t, e) { return this.decodeUnchecked(t, e); }decodeUnchecked (t, e) { switch (t) { case 'token':return (function (t) { return Gt.decode(t); }(e)); case 'mint':return (function (t) { return Wt.decode(t); }(e)); default:throw new Error(`Invalid account name: ${t}`); } }memcmp (t, e) { switch (t) { case 'token':return { dataSize: 165 }; case 'mint':return { dataSize: 82 }; default:throw new Error(`Invalid account name: ${t}`); } }size (t) { let e; return (e = Y(this.idl, t)) !== null && void 0 !== e ? e : 0; }} const Wt = kt([$t(jt(), 'mintAuthority'), Ut('supply'), St('decimals'), (function (t) { return new Rt(St(), Nt, Kt, t); }('isInitialized')), $t(jt(), 'freezeAuthority')]); const Gt = kt([jt('mint'), jt('authority'), Ut('amount'), $t(jt(), 'delegate'), St('state'), $t(Ut(), 'isNative'), Ut('delegatedAmount'), $t(jt(), 'closeAuthority')]); class Ht {constructor (t) {}decode (t) { throw new Error('SPL token program does not have events'); }} class Jt {constructor (t) { this.instruction = new Mt(t), this.accounts = new qt(t), this.events = new Ht(t), this.state = new Dt(t); }} const Zt = Object.freeze({ __proto__: null, hash: function (t) { return h(t); } }); function Qt (t) { const e = new Map(); return t.errors && t.errors.forEach((t) => { let r; const n = (r = t.msg) !== null && void 0 !== r ? r : t.name; e.set(t.code, n); }), e; } function Xt (t, ...e) { if (t.args.length != e.length) { throw new Error('Invalid argument length'); } const r = {}; let n = 0; return t.args.forEach((t) => { r[t.name] = e[n], n += 1; }), r; } function Yt (t, e = {}) { t.forEach((t) => { if ('accounts' in t) { Yt(t.accounts, e[t.name]); } else if (void 0 === e[t.name]) { throw new Error(`Invalid arguments: ${t.name} not provided.`); } }); } function te (t) { return t instanceof r ? t : new r(t); } async function ee (t, e, r) { if (e.length <= 99) { return await re(t, e, r); } { const o = (n = e, i = 99, Array.apply(0, new Array(Math.ceil(n.length / i))).map((t, e) => n.slice(e * i, (e + 1) * i))); return (await Promise.all(o.map(e => re(t, e, r)))).flat(); } let n, i; } async function re (e, n, i) { const o = i != null ? i : e.commitment; const s = [n.map(t => t.toBase58())]; o && s.push({ commitment: o }); const a = await e._rpcRequest('getMultipleAccounts', s); if (a.error) { throw new Error('failed to get info about accounts ' + n.map(t => t.toBase58()).join(', ') + ': ' + a.error.message); } m(void 0 !== a.result); const c = []; for (const e of a.result.value) { let n = null; if (e !== null) { if (a.result.value) { const { executable: i, owner: o, lamports: s, data: a } = e; m(a[1] === 'base64'), n = { executable: i, owner: new r(o), lamports: s, data: t.from(a[0], 'base64') }; } if (n === null) { throw new Error('Invalid response'); } c.push(n); } else { c.push(null); } } return c.map((t, e) => t === null ? null : { publicKey: n[e], account: t }); } const ne = Object.freeze({ __proto__: null, invoke: async function (t, e, r, o) { t = te(t), o || (o = T()); const s = new n(); return s.add(new i({ programId: t, keys: e != null ? e : [], data: r })), await o.send(s); }, getMultipleAccounts: ee }); function ie (e, n, i) { const o = t.concat([e.toBuffer(), t.from(n), i.toBuffer()]); const s = h.digest(o); return new r(t.from(s)); } function oe (e, n) { let i = t.alloc(0); e.forEach(function (e) { if (e.length > 32) { throw new TypeError('Max seed length exceeded'); } i = t.concat([i, ae(e)]); }), i = t.concat([i, n.toBuffer(), t.from('ProgramDerivedAddress')]); const o = h(new Uint8Array(i)); const s = new c(o, 16).toArray(void 0, 32); if (r.isOnCurve(new Uint8Array(s))) { throw new Error('Invalid seeds, address must fall off the curve'); } return new r(s); } function se (e, r) { let n; let i = 255; for (;i != 0;) { try { n = oe(e.concat(t.from([i])), r); } catch (t) { if (t instanceof TypeError) { throw t; } i--; continue; } return [n, i]; } throw new Error('Unable to find a viable program address nonce'); } const ae = e => e instanceof t ? e : e instanceof Uint8Array ? t.from(e.buffer, e.byteOffset, e.byteLength) : t.from(e); async function ce (e, ...n) { const i = [t.from([97, 110, 99, 104, 111, 114])]; n.forEach((e) => { i.push(e instanceof t ? e : te(e).toBuffer()); }); const [o] = await r.findProgramAddress(i, te(e)); return o; } const ue = Object.freeze({ __proto__: null, createWithSeedSync: ie, createProgramAddressSync: oe, findProgramAddressSync: se, associated: ce }); const le = new r('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'); const de = new r('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'); const he = Object.freeze({ __proto__: null, TOKEN_PROGRAM_ID: le, ASSOCIATED_PROGRAM_ID: de, associatedAddress: async function ({ mint: t, owner: e }) { return (await r.findProgramAddress([e.toBuffer(), le.toBuffer(), t.toBuffer()], de))[0]; } }); const pe = { exports: {} }; !(function (t, e) { const r = typeof self !== 'undefined' ? self : ct; const n = (function () { function t () { this.fetch = !1, this.DOMException = r.DOMException; } return t.prototype = r, new t(); }()); !(function (t) { !(function (e) { const r = 'URLSearchParams' in t; const n = 'Symbol' in t && 'iterator' in Symbol; const i = 'FileReader' in t && 'Blob' in t && (function () { try { return new Blob(), !0; } catch (t) { return !1; } }()); const o = 'FormData' in t; const s = 'ArrayBuffer' in t; if (s) { const a = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]']; var c = ArrayBuffer.isView || function (t) { return t && a.includes(Object.prototype.toString.call(t)); }; } function u (t) { if (typeof t !== 'string' && (t = String(t)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(t)) { throw new TypeError('Invalid character in header field name'); } return t.toLowerCase(); } function l (t) { return typeof t !== 'string' && (t = String(t)), t; } function d (t) { const e = { next: function () { const e = t.shift(); return { done: void 0 === e, value: e }; } }; return n && (e[Symbol.iterator] = function () { return e; }), e; } function h (t) { this.map = {}, t instanceof h ? t.forEach(function (t, e) { this.append(e, t); }, this) : Array.isArray(t) ? t.forEach(function (t) { this.append(t[0], t[1]); }, this) : t && Object.getOwnPropertyNames(t).forEach(function (e) { this.append(e, t[e]); }, this); } function p (t) { if (t.bodyUsed) { return Promise.reject(new TypeError('Already read')); } t.bodyUsed = !0; } function f (t) { return new Promise(function (e, r) { t.onload = function () { e(t.result); }, t.onerror = function () { r(t.error); }; }); } function m (t) { const e = new FileReader(); const r = f(e); return e.readAsArrayBuffer(t), r; } function y (t) { if (t.slice) { return t.slice(0); } const e = new Uint8Array(t.byteLength); return e.set(new Uint8Array(t)), e.buffer; } function g () { return this.bodyUsed = !1, this._initBody = function (t) { let e; this._bodyInit = t, t ? typeof t === 'string' ? this._bodyText = t : i && Blob.prototype.isPrototypeOf(t) ? this._bodyBlob = t : o && FormData.prototype.isPrototypeOf(t) ? this._bodyFormData = t : r && URLSearchParams.prototype.isPrototypeOf(t) ? this._bodyText = t.toString() : s && i && ((e = t) && DataView.prototype.isPrototypeOf(e)) ? (this._bodyArrayBuffer = y(t.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : s && (ArrayBuffer.prototype.isPrototypeOf(t) || c(t)) ? this._bodyArrayBuffer = y(t) : this._bodyText = t = Object.prototype.toString.call(t) : this._bodyText = '', this.headers.get('content-type') || (typeof t === 'string' ? this.headers.set('content-type', 'text/plain;charset=UTF-8') : this._bodyBlob && this._bodyBlob.type ? this.headers.set('content-type', this._bodyBlob.type) : r && URLSearchParams.prototype.isPrototypeOf(t) && this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')); }, i && (this.blob = function () { const t = p(this); if (t) { return t; } if (this._bodyBlob) { return Promise.resolve(this._bodyBlob); } if (this._bodyArrayBuffer) { return Promise.resolve(new Blob([this._bodyArrayBuffer])); } if (this._bodyFormData) { throw new Error('could not read FormData body as blob'); } return Promise.resolve(new Blob([this._bodyText])); }, this.arrayBuffer = function () { return this._bodyArrayBuffer ? p(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(m); }), this.text = function () { const t = p(this); if (t) { return t; } if (this._bodyBlob) { return (function (t) { const e = new FileReader(); const r = f(e); return e.readAsText(t), r; }(this._bodyBlob)); } if (this._bodyArrayBuffer) { return Promise.resolve(function (t) { for (var e = new Uint8Array(t), r = new Array(e.length), n = 0; n < e.length; n++) { r[n] = String.fromCharCode(e[n]); } return r.join(''); }(this._bodyArrayBuffer)); } if (this._bodyFormData) { throw new Error('could not read FormData body as text'); } return Promise.resolve(this._bodyText); }, o && (this.formData = function () { return this.text().then(b); }), this.json = function () { return this.text().then(JSON.parse); }, this; }h.prototype.append = function (t, e) { t = u(t), e = l(e); const r = this.map[t]; this.map[t] = r ? r + ', ' + e : e; }, h.prototype.delete = function (t) { delete this.map[u(t)]; }, h.prototype.get = function (t) { return t = u(t), this.has(t) ? this.map[t] : null; }, h.prototype.has = function (t) { return this.map.hasOwnProperty(u(t)); }, h.prototype.set = function (t, e) { this.map[u(t)] = l(e); }, h.prototype.forEach = function (t, e) { for (const r in this.map) { this.map.hasOwnProperty(r) && t.call(e, this.map[r], r, this); } }, h.prototype.keys = function () { const t = []; return this.forEach(function (e, r) { t.push(r); }), d(t); }, h.prototype.values = function () { const t = []; return this.forEach(function (e) { t.push(e); }), d(t); }, h.prototype.entries = function () { const t = []; return this.forEach(function (e, r) { t.push([r, e]); }), d(t); }, n && (h.prototype[Symbol.iterator] = h.prototype.entries); const w = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']; function v (t, e) { let r; let n; let i = (e = e || {}).body; if (t instanceof v) { if (t.bodyUsed) { throw new TypeError('Already read'); } this.url = t.url, this.credentials = t.credentials, e.headers || (this.headers = new h(t.headers)), this.method = t.method, this.mode = t.mode, this.signal = t.signal, i || t._bodyInit == null || (i = t._bodyInit, t.bodyUsed = !0); } else { this.url = String(t); } if (this.credentials = e.credentials || this.credentials || 'same-origin', !e.headers && this.headers || (this.headers = new h(e.headers)), this.method = (r = e.method || this.method || 'GET', n = r.toUpperCase(), w.includes(n) ? n : r), this.mode = e.mode || this.mode || null, this.signal = e.signal || this.signal, this.referrer = null, (this.method === 'GET' || this.method === 'HEAD') && i) { throw new TypeError('Body not allowed for GET or HEAD requests'); } this._initBody(i); } function b (t) { const e = new FormData(); return t.trim().split('&').forEach(function (t) { if (t) { const r = t.split('='); const n = r.shift().replace(/\+/g, ' '); const i = r.join('=').replace(/\+/g, ' '); e.append(decodeURIComponent(n), decodeURIComponent(i)); } }), e; } function _ (t, e) { e || (e = {}), this.type = 'default', this.status = void 0 === e.status ? 200 : e.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = 'statusText' in e ? e.statusText : 'OK', this.headers = new h(e.headers), this.url = e.url || '', this._initBody(t); }v.prototype.clone = function () { return new v(this, { body: this._bodyInit }); }, g.call(v.prototype), g.call(_.prototype), _.prototype.clone = function () { return new _(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new h(this.headers), url: this.url }); }, _.error = function () { const t = new _(null, { status: 0, statusText: '' }); return t.type = 'error', t; }; const A = [301, 302, 303, 307, 308]; _.redirect = function (t, e) { if (!A.includes(e)) { throw new RangeError('Invalid status code'); } return new _(null, { status: e, headers: { location: t } }); }, e.DOMException = t.DOMException; try { new e.DOMException(); } catch (t) { e.DOMException = function (t, e) { this.message = t, this.name = e; const r = Error(t); this.stack = r.stack; }, e.DOMException.prototype = Object.create(Error.prototype), e.DOMException.prototype.constructor = e.DOMException; } function E (t, r) { return new Promise(function (n, o) { const s = new v(t, r); if (s.signal && s.signal.aborted) { return o(new e.DOMException('Aborted', 'AbortError')); } const a = new XMLHttpRequest(); function c () { a.abort(); }a.onload = function () { let t; let e; const r = { status: a.status, statusText: a.statusText, headers: (t = a.getAllResponseHeaders() || '', e = new h(), t.replace(/\r?\n[\t ]+/g, ' ').split(/\r?\n/).forEach(function (t) { const r = t.split(':'); const n = r.shift().trim(); if (n) { const i = r.join(':').trim(); e.append(n, i); } }), e) }; r.url = 'responseURL' in a ? a.responseURL : r.headers.get('X-Request-URL'); const i = 'response' in a ? a.response : a.responseText; n(new _(i, r)); }, a.onerror = function () { o(new TypeError('Network request failed')); }, a.ontimeout = function () { o(new TypeError('Network request failed')); }, a.onabort = function () { o(new e.DOMException('Aborted', 'AbortError')); }, a.open(s.method, s.url, !0), s.credentials === 'include' ? a.withCredentials = !0 : s.credentials === 'omit' && (a.withCredentials = !1), 'responseType' in a && i && (a.responseType = 'blob'), s.headers.forEach(function (t, e) { a.setRequestHeader(e, t); }), s.signal && (s.signal.addEventListener('abort', c), a.onreadystatechange = function () { a.readyState === 4 && s.signal.removeEventListener('abort', c); }), a.send(void 0 === s._bodyInit ? null : s._bodyInit); }); }E.polyfill = !0, t.fetch || (t.fetch = E, t.Headers = h, t.Request = v, t.Response = _), e.Headers = h, e.Request = v, e.Response = _, e.fetch = E, Object.defineProperty(e, '__esModule', { value: !0 }); }({})); }(n)), n.fetch.ponyfill = !0, delete n.fetch.polyfill; const i = n; (e = i.fetch).default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, t.exports = e; }(pe, pe.exports)); const fe = ut(pe.exports); async function me (t, e) { const r = await t.getAccountInfo(e); if (r === null) { throw new Error('program account not found'); } const { program: n } = ge(r.data); const i = await t.getAccountInfo(n.programdataAddress); if (i === null) { throw new Error('program data account not found'); } const { programData: o } = ge(i.data); return o; } const ye = p.rustEnum([p.struct([], 'uninitialized'), p.struct([p.option(p.publicKey(), 'authorityAddress')], 'buffer'), p.struct([p.publicKey('programdataAddress')], 'program'), p.struct([p.u64('slot'), p.option(p.publicKey(), 'upgradeAuthorityAddress')], 'programData')], void 0, p.u32()); function ge (t) { return ye.decode(t); } const we = Object.freeze({ __proto__: null, verifiedBuild: async function (t, e, r = 5) { const n = `https://anchor.projectserum.com/api/v0/program/${e.toString()}/latest?limit=${r}`; const [i, o] = await Promise.all([me(t, e), fe(n)]); const s = (await o.json()).filter(t => !t.aborted && t.state === 'Built' && t.verified === 'Verified'); if (s.length === 0) { return null; } const a = s[0]; return i.slot.toNumber() !== a.verified_slot ? null : a; }, fetchData: me, decodeUpgradeableLoaderState: ge }); const ve = Object.freeze({ __proto__: null, sha256: Zt, rpc: ne, publicKey: ue, bytes: I, token: he, features: C, registry: we }); const be = p.struct([p.publicKey('authority'), p.vecU8('data')]); function _e (t, e) { let r, n; let i = {}; const o = t.args ? t.args.length : 0; if (e.length > o) { if (e.length !== o + 1) { throw new Error(`provided too many arguments ${e} to instruction ${t == null ? void 0 : t.name} expecting: ${(n = (r = t.args) === null || void 0 === r ? void 0 : r.map(t => t.name)) !== null && void 0 !== n ? n : []}`); } i = e.pop(); } return [e, i]; } class Ae {static build (t, e, r) { if (t.name === '_inner') { throw new D('the _inner name is reserved'); } const n = (...o) => { const [s, a] = _e(t, [...o]); Yt(t.accounts, a.accounts); const c = n.accounts(a.accounts); return void 0 !== a.remainingAccounts && c.push(...a.remainingAccounts), z('debug-logs') && console.log('Outgoing account metas:', c), new i({ keys: c, programId: r, data: e(t.name, Xt(t, ...s)) }); }; return n.accounts = e => Ae.accountsArray(e, t.accounts, t.name), n; } static accountsArray (t, e, r) { return t ? e.map((e) => { if (void 0 !== ('accounts' in e ? e.accounts : void 0)) { const n = t[e.name]; return Ae.accountsArray(n, e.accounts, r).flat(); } { const n = e; let i; try { i = te(t[e.name]); } catch (t) { throw new Error(`Wrong input type for account "${e.name}" in the instruction accounts object${void 0 !== r ? ' for instruction "' + r + '"' : ''}. Expected PublicKey or string.`); } return { pubkey: i, isWritable: n.isMut, isSigner: n.isSigner }; } }).flat() : []; }} class Ee {static build (t, e, r, n) { return async (...i) => { const o = e(...i); const [, s] = _e(t, [...i]); try { return await n.send(o, s.signers, s.options); } catch (t) { throw R(t, r); } }; }} class Se {static build (t, e) { return (...r) => { let i, o, s; const [, a] = _e(t, [...r]); const c = new n(); if (a.preInstructions && a.instructions) { throw new Error('instructions is deprecated, use preInstructions'); } return (i = a.preInstructions) === null || void 0 === i || i.forEach(t => c.add(t)), (o = a.instructions) === null || void 0 === o || o.forEach(t => c.add(t)), c.add(e(...r)), (s = a.postInstructions) === null || void 0 === s || s.forEach(t => c.add(t)), c; }; }} class Ie {constructor (t, e, r = T(), n = new at(t)) { this.provider = r, this.coder = n, this._idl = t, this._programId = e, this._address = ke(e), this._sub = null; const [i, s, a] = (() => { let i; const s = {}; const a = {}; const c = {}; return (i = t.state) === null || void 0 === i || i.methods.forEach((i) => { const u = Ae.build(i, (t, e) => n.instruction.encodeState(t, e), e); u.accounts = (t) => { const n = (function (t, e, r, n) { if (r.name === 'new') { const [r] = se([], t); return [{ pubkey: e.wallet.publicKey, isWritable: !1, isSigner: !0 }, { pubkey: ke(t), isWritable: !0, isSigner: !1 }, { pubkey: r, isWritable: !1, isSigner: !1 }, { pubkey: o.programId, isWritable: !1, isSigner: !1 }, { pubkey: t, isWritable: !1, isSigner: !1 }]; } return Yt(r.accounts, n), [{ pubkey: ke(t), isWritable: !0, isSigner: !1 }]; }(e, r, i, t)); return n.concat(Ae.accountsArray(t, i.accounts, i.name)); }; const l = Se.build(i, u); const h = Ee.build(i, l, Qt(t), r); const p = d(i.name); s[p] = u, a[p] = l, c[p] = h; }), [s, a, c]; })(); this.instruction = i, this.transaction = s, this.rpc = a; } get programId () { return this._programId; } async fetch () { const t = this.address(); const e = await this.provider.connection.getAccountInfo(t); if (e === null) { throw new Error(`Account does not exist ${t.toString()}`); } const r = this._idl.state; if (!r) { throw new Error('State is not specified in IDL.'); } if ((await st(r.struct.name)).compare(e.data.slice(0, 8))) { throw new Error('Invalid account discriminator'); } return this.coder.state.decode(e.data); }address () { return this._address; }subscribe (t) { if (this._sub !== null) { return this._sub.ee; } const e = new g(); const r = this.provider.connection.onAccountChange(this.address(), (t) => { const r = this.coder.state.decode(t.data); e.emit('change', r); }, t); return this._sub = { ee: e, listener: r }, e; }unsubscribe () { this._sub !== null && this.provider.connection.removeAccountChangeListener(this._sub.listener).then(async () => { this._sub = null; }).catch(console.error); }} function ke (t) { const [e] = se([], t); return ie(e, 'unversioned', t); } class xe {constructor (t, e, r, n, i) { this._idlAccount = e, this._programId = r, this._provider = n != null ? n : T(), this._coder = i != null ? i : new at(t), this._size = this._coder.accounts.size(e); } get size () { return this._size; } get programId () { return this._programId; } get provider () { return this._provider; } get coder () { return this._coder; } async fetchNullable (t, e) { const r = await this.getAccountInfo(t, e); return r === null ? null : this._coder.accounts.decode(this._idlAccount.name, r.data); } async fetch (t, e) { const r = await this.fetchNullable(t, e); if (r === null) { throw new Error(`Account does not exist ${t.toString()}`); } return r; } async fetchMultiple (t, e) { return (await ee(this._provider.connection, t.map(t => te(t)), e)).map(t => t == null ? null : this._coder.accounts.decode(this._idlAccount.name, t == null ? void 0 : t.account.data)); } async all (t) { return (await this._provider.connection.getProgramAccounts(this._programId, { commitment: this._provider.connection.commitment, filters: [{ memcmp: this.coder.accounts.memcmp(this._idlAccount.name, t instanceof Buffer ? t : void 0) }, ...Array.isArray(t) ? t : []] })).map(({ pubkey: t, account: e }) => ({ publicKey: t, account: this._coder.accounts.decode(this._idlAccount.name, e.data) })); }subscribe (t, e) { const r = Me.get(t.toString()); if (r) { return r.ee; } const n = new g(); t = te(t); const i = this._provider.connection.onAccountChange(t, (t) => { const e = this._coder.accounts.decode(this._idlAccount.name, t.data); n.emit('change', e); }, e); return Me.set(t.toString(), { ee: n, listener: i }), n; } async unsubscribe (t) { const e = Me.get(t.toString()); e ? Me && await this._provider.connection.removeAccountChangeListener(e.listener).then(() => { Me.delete(t.toString()); }).catch(console.error) : console.warn('Address is not subscribed'); } async createInstruction (t, e) { const r = this.size; return o.createAccount({ fromPubkey: this._provider.wallet.publicKey, newAccountPubkey: t.publicKey, space: e != null ? e : r, lamports: await this._provider.connection.getMinimumBalanceForRentExemption(e != null ? e : r), programId: this._programId }); } async associated (...t) { const e = await this.associatedAddress(...t); return await this.fetch(e); } async associatedAddress (...t) { return await ce(this._programId, ...t); } async getAccountInfo (t, e) { return await this._provider.connection.getAccountInfo(te(t), e); }} const Me = new Map(); const Le = 'Program log: '.length; const Te = 'Program data: '.length; class Pe {constructor (t, e, r) { this._programId = t, this._provider = e, this._eventParser = new Be(t, r), this._eventCallbacks = new Map(), this._eventListeners = new Map(), this._listenerIdCount = 0; }addEventListener (t, e) { let r; const n = this._listenerIdCount; return this._listenerIdCount += 1, t in this._eventCallbacks || this._eventListeners.set(t, []), this._eventListeners.set(t, ((r = this._eventListeners.get(t)) !== null && void 0 !== r ? r : []).concat(n)), this._eventCallbacks.set(n, [t, e]), void 0 !== this._onLogsSubscriptionId || (this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (t, e) => { t.err || this._eventParser.parseLogs(t.logs, (t) => { const r = this._eventListeners.get(t.name); r && r.forEach((r) => { const n = this._eventCallbacks.get(r); if (n) { const [, r] = n; r(t.data, e.slot); } }); }); })), n; } async removeEventListener (t) { const e = this._eventCallbacks.get(t); if (!e) { throw new Error(`Event listener ${t} doesn't exist!`); } const [r] = e; let n = this._eventListeners.get(r); if (!n) { throw new Error(`Event listeners don't exist for ${r}!`); } this._eventCallbacks.delete(t), n = n.filter(e => e !== t), n.length === 0 && this._eventListeners.delete(r), this._eventCallbacks.size == 0 && (f.ok(this._eventListeners.size === 0), void 0 !== this._onLogsSubscriptionId && (await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId), this._onLogsSubscriptionId = void 0)); }} class Be {constructor (t, e) { this.coder = e, this.programId = t; }parseLogs (t, e) { const r = new ze(t); const n = new Oe(r.next()); let i = r.next(); for (;i !== null;) { const [t, o, s] = this.handleLog(n, i); t && e(t), o && n.push(o), s && n.pop(), i = r.next(); } }handleLog (t, e) { return t.stack.length > 0 && t.program() === this.programId.toString() ? this.handleProgramLog(e) : [null, ...this.handleSystemLog(e)]; }handleProgramLog (t) { if (t.startsWith('Program log: ') || t.startsWith('Program data: ')) { const e = t.startsWith('Program log: ') ? t.slice(Le) : t.slice(Te); return [this.coder.events.decode(e), null, !1]; } return [null, ...this.handleSystemLog(t)]; }handleSystemLog (t) { const e = t.split(':')[0]; return e.match(/^Program (.*) success/g) !== null ? [null, !0] : e.startsWith(`Program ${this.programId.toString()} invoke`) ? [this.programId.toString(), !1] : e.includes('invoke') ? ['cpi', !1] : [null, !1]; }} class Oe {constructor (t) { let e; const r = (e = /^Program (.*) invoke.*$/g.exec(t)) === null || void 0 === e ? void 0 : e[1]; if (!r) { throw new Error('Could not find program invocation log line'); } this.stack = [r]; }program () { return f.ok(this.stack.length > 0), this.stack[this.stack.length - 1]; }push (t) { this.stack.push(t); }pop () { f.ok(this.stack.length > 0), this.stack.pop(); }} class ze {constructor (t) { this.logs = t; }next () { if (this.logs.length === 0) { return null; } const t = this.logs[0]; return this.logs = this.logs.slice(1), t; }} const Ce = new r('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'); function De () { return new Jt(Ue); } const Ue = { version: '0.1.0', name: 'spl_token', instructions: [{ name: 'initializeMint', accounts: [{ name: 'mint', isMut: !0, isSigner: !1 }, { name: 'rent', isMut: !1, isSigner: !1 }], args: [{ name: 'decimals', type: 'u8' }, { name: 'mintAuthority', type: 'publicKey' }, { name: 'freezeAuthority', type: { coption: 'publicKey' } }] }, { name: 'initializeAccount', accounts: [{ name: 'account', isMut: !0, isSigner: !1 }, { name: 'mint', isMut: !1, isSigner: !1 }, { name: 'authority', isMut: !1, isSigner: !1 }, { name: 'rent', isMut: !1, isSigner: !1 }], args: [] }, { name: 'initializeMultisig', accounts: [{ name: 'account', isMut: !0, isSigner: !1 }, { name: 'rent', isMut: !1, isSigner: !1 }], args: [{ name: 'm', type: 'u8' }] }, { name: 'transfer', accounts: [{ name: 'source', isMut: !0, isSigner: !1 }, { name: 'destination', isMut: !0, isSigner: !1 }, { name: 'authority', isMut: !1, isSigner: !0 }], args: [{ name: 'amount', type: 'u64' }] }, { name: 'approve', accounts: [{ name: 'source', isMut: !0, isSigner: !1 }, { name: 'delegate', isMut: !1, isSigner: !1 }, { name: 'authority', isMut: !1, isSigner: !0 }], args: [{ name: 'amount', type: 'u64' }] }, { name: 'revoke', accounts: [{ name: 'source', isMut: !0, isSigner: !1 }, { name: 'authority', isMut: !1, isSigner: !0 }], args: [] }, { name: 'setAuthority', accounts: [{ name: 'mint', isMut: !0, isSigner: !1 }, { name: 'authority', isMut: !1, isSigner: !0 }], args: [{ name: 'authorityType', type: 'u8' }, { name: 'newAuthority', type: { coption: 'publicKey' } }] }, { name: 'mintTo', accounts: [{ name: 'mint', isMut: !0, isSigner: !1 }, { name: 'to', isMut: !0, isSigner: !1 }, { name: 'authority', isMut: !1, isSigner: !0 }], args: [{ name: 'amount', type: 'u64' }] }, { name: 'burn', accounts: [{ name: 'source', isMut: !0, isSigner: !1 }, { name: 'mint', isMut: !0, isSigner: !1 }, { name: 'authority', isMut: !1, isSigner: !0 }], args: [{ name: 'amount', type: 'u64' }] }, { name: 'closeAccount', accounts: [{ name: 'account', isMut: !0, isSigner: !1 }, { name: 'destination', isMut: !0, isSigner: !1 }, { name: 'authority', isMut: !1, isSigner: !1 }], args: [] }, { name: 'freezeAccount', accounts: [{ name: 'account', isMut: !0, isSigner: !1 }, { name: 'mint', isMut: !1, isSigner: !1 }, { name: 'authority', isMut: !1, isSigner: !0 }], args: [] }, { name: 'thawAccount', accounts: [{ name: 'account', isMut: !0, isSigner: !1 }, { name: 'mint', isMut: !1, isSigner: !1 }, { name: 'authority', isMut: !1, isSigner: !0 }], args: [] }, { name: 'transferChecked', accounts: [{ name: 'source', isMut: !0, isSigner: !1 }, { name: 'mint', isMut: !1, isSigner: !1 }, { name: 'destination', isMut: !0, isSigner: !1 }, { name: 'authority', isMut: !1, isSigner: !0 }], args: [{ name: 'amount', type: 'u64' }, { name: 'decimals', type: 'u8' }] }, { name: 'approveChecked', accounts: [{ name: 'source', isMut: !0, isSigner: !1 }, { name: 'mint', isMut: !1, isSigner: !1 }, { name: 'delegate', isMut: !1, isSigner: !1 }, { name: 'authority', isMut: !1, isSigner: !0 }], args: [{ name: 'amount', type: 'u64' }, { name: 'decimals', type: 'u8' }] }, { name: 'mintToChecked', accounts: [{ name: 'mint', isMut: !0, isSigner: !1 }, { name: 'to', isMut: !0, isSigner: !1 }, { name: 'authority', isMut: !1, isSigner: !0 }], args: [{ name: 'amount', type: 'u64' }, { name: 'decimals', type: 'u8' }] }, { name: 'burnChecked', accounts: [{ name: 'source', isMut: !0, isSigner: !1 }, { name: 'mint', isMut: !0, isSigner: !1 }, { name: 'authority', isMut: !1, isSigner: !0 }], args: [{ name: 'amount', type: 'u64' }, { name: 'decimals', type: 'u8' }] }, { name: 'initializeAccount2', accounts: [{ name: 'account', isMut: !0, isSigner: !1 }, { name: 'mint', isMut: !1, isSigner: !1 }, { name: 'rent', isMut: !1, isSigner: !1 }], args: [{ name: 'authority', type: 'publicKey' }] }, { name: 'syncNative', accounts: [{ name: 'account', isMut: !0, isSigner: !1 }], args: [] }, { name: 'initializeAccount3', accounts: [{ name: 'account', isMut: !0, isSigner: !1 }, { name: 'mint', isMut: !1, isSigner: !1 }], args: [{ name: 'authority', type: 'publicKey' }] }, { name: 'initializeMultisig2', accounts: [{ name: 'account', isMut: !0, isSigner: !1 }], args: [{ name: 'm', type: 'u8' }] }, { name: 'initializeMint2', accounts: [{ name: 'mint', isMut: !0, isSigner: !1 }], args: [{ name: 'decimals', type: 'u8' }, { name: 'mintAuthority', type: 'publicKey' }, { name: 'freezeAuthority', type: { coption: 'publicKey' } }] }], accounts: [{ name: 'mint', type: { kind: 'struct', fields: [{ name: 'mintAuthority', type: { coption: 'publicKey' } }, { name: 'supply', type: 'u64' }, { name: 'decimals', type: 'u8' }, { name: 'isInitialized', type: 'bool' }, { name: 'freezeAuthority', type: { coption: 'publicKey' } }] } }, { name: 'token', type: { kind: 'struct', fields: [{ name: 'mint', type: 'publicKey' }, { name: 'authority', type: 'publicKey' }, { name: 'amount', type: 'u64' }, { name: 'delegate', type: { coption: 'publicKey' } }, { name: 'state', type: 'u8' }, { name: 'isNative', type: { coption: 'u64' } }, { name: 'delegatedAmount', type: 'u64' }, { name: 'closeAuthority', type: { coption: 'publicKey' } }] } }] }; class je {constructor (t, e, r, n, i, o) { this._args = t, this._accounts = e, this._provider = r, this._programId = n, this._idlIx = i, this._accountStore = new $e(r, o); } async resolve () { for (let t = 0; t < this._idlIx.accounts.length; t += 1) { const e = this._idlIx.accounts[t]; const r = d(e.name); e.pda && e.pda.seeds.length > 0 && !this._accounts[r] ? await this.autoPopulatePda(e) : !e.isSigner || this._accounts[r] ? Reflect.has(je.CONST_ACCOUNTS, r) && !this._accounts[r] && (this._accounts[r] = je.CONST_ACCOUNTS[r]) : this._accounts[r] = this._provider.wallet.publicKey; } } async autoPopulatePda (t) { if (!t.pda || !t.pda.seeds) { throw new Error('Must have seeds'); } const e = await Promise.all(t.pda.seeds.map(t => this.toBuffer(t))); const n = await this.parseProgramId(t); const [i] = await r.findProgramAddress(e, n); this._accounts[d(t.name)] = i; } async parseProgramId (t) { let e; if (!((e = t.pda) === null || void 0 === e ? void 0 : e.programId)) { return this._programId; } switch (t.pda.programId.kind) { case 'const':return new r(this.toBufferConst(t.pda.programId.value)); case 'arg':return this.argValue(t.pda.programId); case 'account':return await this.accountValue(t.pda.programId); default:throw new Error(`Unexpected program seed kind: ${t.pda.programId.kind}`); } } async toBuffer (t) { switch (t.kind) { case 'const':return this.toBufferConst(t); case 'arg':return await this.toBufferArg(t); case 'account':return await this.toBufferAccount(t); default:throw new Error(`Unexpected seed kind: ${t.kind}`); } }toBufferConst (t) { return this.toBufferValue(t.type, t.value); } async toBufferArg (t) { const e = this.argValue(t); return this.toBufferValue(t.type, e); }argValue (t) { const e = d(t.path.split('.')[0]); const r = this._idlIx.args.findIndex(t => t.name === e); if (r === -1) { throw new Error(`Unable to find argument for seed: ${e}`); } return this._args[r]; } async toBufferAccount (t) { const e = await this.accountValue(t); return this.toBufferValue(t.type, e); } async accountValue (t) { const e = t.path.split('.'); const r = e[0]; const n = this._accounts[d(r)]; if (e.length === 1) { return n; } const i = await this._accountStore.fetchAccount(t.account, n); return this.parseAccountValue(i, e.slice(1)); }parseAccountValue (t, e) { let r; for (;e.length > 0;) { r = t[d(e[0])], e = e.slice(1); } return r; }toBufferValue (t, e) { switch (t) { case 'u8':return Buffer.from([e]); case 'u16':const r = Buffer.alloc(2); return r.writeUInt16LE(e), r; case 'u32':const n = Buffer.alloc(4); return n.writeUInt32LE(e), n; case 'u64':const i = Buffer.alloc(8); return i.writeBigUInt64LE(BigInt(e)), i; case 'string':return Buffer.from(b(e)); case 'publicKey':return e.toBuffer(); default:if (t.array) { return Buffer.from(e); } throw new Error(`Unexpected seed type: ${t}`); } }}je.CONST_ACCOUNTS = { systemProgram: o.programId, tokenProgram: le, associatedTokenProgram: de, rent: s }; class $e {constructor (t, e) { this._provider = t, this._accounts = e, this._cache = new Map(); } async fetchAccount (t, e) { const r = e.toString(); if (!this._cache.has(r)) { if (t === 'TokenAccount') { const t = await this._provider.connection.getAccountInfo(e); if (t === null) { throw new Error(`invalid account info for ${r}`); } const n = De().accounts.decode('token', t.data); this._cache.set(r, n); } else { const n = this._accounts[d(t)].fetch(e); this._cache.set(r, n); } } return this._cache.get(r); }} class Re {static build (t, e, r, n, i, o, s, a) { return (...c) => new Ve(c, n, i, o, s, t, e, r, a); }} class Ve {constructor (t, e, r, n, i, o, s, a, c) { this._args = t, this._ixFn = e, this._txFn = r, this._rpcFn = n, this._simulateFn = i, this._accounts = {}, this._remainingAccounts = [], this._signers = [], this._preInstructions = [], this._postInstructions = [], this._accountsResolver = new je(t, this._accounts, o, s, a, c); }accounts (t) { return Object.assign(this._accounts, t), this; }signers (t) { return this._signers = this._signers.concat(t), this; }remainingAccounts (t) { return this._remainingAccounts = this._remainingAccounts.concat(t), this; }preInstructions (t) { return this._preInstructions = this._preInstructions.concat(t), this; }postInstructions (t) { return this._postInstructions = this._postInstructions.concat(t), this; } async rpc (t) { return await this._accountsResolver.resolve(), this._rpcFn(...this._args, { accounts: this._accounts, signers: this._signers, remainingAccounts: this._remainingAccounts, preInstructions: this._preInstructions, postInstructions: this._postInstructions, options: t }); } async simulate (t) { return await this._accountsResolver.resolve(), this._simulateFn(...this._args, { accounts: this._accounts, signers: this._signers, remainingAccounts: this._remainingAccounts, preInstructions: this._preInstructions, postInstructions: this._postInstructions, options: t }); } async instruction () { return await this._accountsResolver.resolve(), this._ixFn(...this._args, { accounts: this._accounts, signers: this._signers, remainingAccounts: this._remainingAccounts, preInstructions: this._preInstructions, postInstructions: this._postInstructions }); } async transaction () { return await this._accountsResolver.resolve(), this._txFn(...this._args, { accounts: this._accounts, signers: this._signers, remainingAccounts: this._remainingAccounts, preInstructions: this._preInstructions, postInstructions: this._postInstructions }); }} class Ne {constructor (t, e, r, n) { e = te(e), r || (r = T()), this._idl = t, this._provider = r, this._programId = e, this._coder = n != null ? n : new at(t), this._events = new Pe(this._programId, r, this._coder); const [i, o, s, a, c, u, l] = class {static build (t, e, r, n) { const i = {}; const o = {}; const s = {}; const a = {}; const c = {}; const u = Qt(t); const l = t.accounts ? class {static build (t, e, r, n) { let i; const o = {}; return (i = t.accounts) === null || void 0 === i || i.forEach((i) => { const s = d(i.name); o[s] = new xe(t, i, r, n, e); }), o; }}.build(t, e, r, n) : {}; const h = class {static build (t, e, r, n) { if (void 0 !== t.state) { return new Ie(t, r, n, e); } }}.build(t, e, r, n); return t.instructions.forEach((h) => { const p = Ae.build(h, (t, r) => e.instruction.encode(t, r), r); const f = Se.build(h, p); const m = Ee.build(h, f, u, n); const y = class {static build (t, e, r, n, i, o, s) { return async (...a) => { const c = e(...a); const [, u] = _e(t, [...a]); let l; try { l = await n.simulate(c, u.signers, u.options); } catch (t) { throw R(t, r); } if (void 0 === l) { throw new Error('Unable to simulate transaction'); } if (l.value.err) { throw new Error(`Simulate error: ${l.value.err.toString()}`); } const d = l.value.logs; if (!d) { throw new Error('Simulated logs not found'); } const h = []; return s.events && new Be(o, i).parseLogs(d, (t) => { h.push(t); }), { events: h, raw: d }; }; }}.build(h, f, u, n, e, r, t); const g = Re.build(n, r, h, p, f, m, y, l); const w = d(h.name); o[w] = p, s[w] = f, i[w] = m, a[w] = y, c[w] = g; }), [i, o, s, l, a, c, h]; }}.build(t, this._coder, e, r); this.rpc = i, this.instruction = o, this.transaction = s, this.account = a, this.simulate = c, this.methods = u, this.state = l; } get programId () { return this._programId; } get idl () { return this._idl; } get coder () { return this._coder; } get provider () { return this._provider; } static async at (t, e) { const r = te(t); const n = await Ne.fetchIdl(r, e); if (!n) { throw new Error(`IDL not found for program: ${t.toString()}`); } return new Ne(n, r, e); } static async fetchIdl (t, e) { e = e != null ? e : T(); const n = te(t); const i = await (async function (t) { const e = (await r.findProgramAddress([], t))[0]; return await r.createWithSeed(e, 'anchor:idl', t); }(n)); const o = await e.connection.getAccountInfo(i); if (!o) { return null; } const s = (a = o.data.slice(8), be.decode(a)); let a; const c = y(s.data); return JSON.parse(v(c)); }addEventListener (t, e) { return this._events.addEventListener(t, e); } async removeEventListener (t) { return await this._events.removeEventListener(t); }} class Ke {static token (t) { return (function (t) { return new Ne(Ue, Ce, t, De()); }(t)); }} export { et as ACCOUNT_DISCRIMINATOR_SIZE, xe as AccountClient, j as AnchorError, rt as BorshAccountsCoder, at as BorshCoder, nt as BorshEventCoder, Z as BorshInstructionCoder, ot as BorshStateCoder, Pe as EventManager, Be as EventParser, D as IdlError, Re as MethodsBuilderFactory, Ne as Program, $ as ProgramError, U as ProgramErrorStack, k as Provider, Ke as Spl, Jt as SplTokenCoder, Ie as StateClient, it as eventDiscriminator, T as getProvider, Qt as parseIdlErrors, L as setProvider, _e as splitArgsAndCtx, st as stateDiscriminator, Xt as toInstruction, te as translateAddress, R as translateError, ve as utils, Yt as validateAccounts };
// # sourceMappingURL=index.js.map
